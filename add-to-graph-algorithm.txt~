This is the algorithm that we will use to add a new type to the lattice.

The algorithm has two phases:
 1. finding the proper placement of the new type with regard to subtypes
 2. adding the necessary information regarding intersection lines.

Some notation:
 L : a type Lattice
 T₁, T₂, ... : types
 T ∈ L : T is represented by a node of L
 L ⊢ φ : φ can be deduced from L (without using ACL2s)
 T:(L) : The lattice resulting from adding T to L.
 
 Γ : the ACL2s logical world
 Γ ⊧ φ : φ can be proven by ACL2s

I leave Γ and L as free variables in efforts to denote that they are
always the 'current' lattice and world.


The 3 properties that our lattice maintains are that:
 1. ∀ (T₁, T₂ ∈ L) . L ⊢ T₁ ⊆ T₂      // Subtype-complete
 2. ∀ (T₁, T₂ ∈ L) . L ⊢ T₁ ∩ T₂ = ∅  // Intersction-complete
 3. ∀ (φ) . [(L ⊢ φ) -> (Γ ⊧ φ)]      // Correctness


Now, we discuss how to add a new type (T) to a lattice (L), assuming
that L is both subtype and intersection complete, and correct.

The algorithm succeeds if T can be added to L such that T:(L) is
guaranteed to maintain subtype and intersection completeness. The
algorithm fails if more information is needed, for some T₁ ∈ L about
either (T ⊆ T₁) or (T ∩ T₁ = ∅). With this in mind, the output set of
the algorithm is:

 {'Success, `(Error subtype ,T ,T₁), `(Error intersection ,T ,T₁)}




